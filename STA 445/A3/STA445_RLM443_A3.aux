\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {subsection}{(1) 1 -- 6 pts. Write a function that calculates the density function of a Uniform continuous variable on the interval \((a,b)\). The function is defined as}{1}{section*.1}\protected@file@percent }
\newlabel{pts.-write-a-function-that-calculates-the-density-function-of-a-uniform-continuous-variable-on-the-interval-ab.-the-function-is-defined-as}{{}{1}{\texorpdfstring {(1) 1 -- 6 pts. Write a function that calculates the density function of a Uniform continuous variable on the interval \((a,b)\). The function is defined as}{(1) 1 -- 6 pts. Write a function that calculates the density function of a Uniform continuous variable on the interval (a,b). The function is defined as}}{section*.1}{}}
\@writefile{toc}{\contentsline {subsubsection}{a. Write your function without regard for it working with vectors of data. Demonstrate that it works by calling the function with a three times, once where \(x<a\) , once where \(a<x<b\), and finally once where \(b<x\).}{1}{section*.2}\protected@file@percent }
\newlabel{a.-write-your-function-without-regard-for-it-working-with-vectors-of-data.-demonstrate-that-it-works-by-calling-the-function-with-a-three-times-once-where-xa-once-where-axb-and-finally-once-where-bx.}{{}{1}{\texorpdfstring {a. Write your function without regard for it working with vectors of data. Demonstrate that it works by calling the function with a three times, once where \(x<a\) , once where \(a<x<b\), and finally once where \(b<x\).}{a. Write your function without regard for it working with vectors of data. Demonstrate that it works by calling the function with a three times, once where x\textless a , once where a\textless x\textless b, and finally once where b\textless x.}}{section*.2}{}}
\@writefile{toc}{\contentsline {subsubsection}{b. Next we force our function to work correctly for a vector of \(x\) values. Modify your function in part (a) so that the core logic is inside a for statement and the loop moves through each element of \(x\) in succession. Your function should look something like this:}{2}{section*.3}\protected@file@percent }
\newlabel{b.-next-we-force-our-function-to-work-correctly-for-a-vector-of-x-values.-modify-your-function-in-part-a-so-that-the-core-logic-is-inside-a-for-statement-and-the-loop-moves-through-each-element-of-x-in-succession.-your-function-should-look-something-like-this}{{}{2}{\texorpdfstring {b. Next we force our function to work correctly for a vector of \(x\) values. Modify your function in part (a) so that the core logic is inside a for statement and the loop moves through each element of \(x\) in succession. Your function should look something like this:}{b. Next we force our function to work correctly for a vector of x values. Modify your function in part (a) so that the core logic is inside a for statement and the loop moves through each element of x in succession. Your function should look something like this:}}{section*.3}{}}
\@writefile{toc}{\contentsline {subsubsection}{Verify that your function works correctly by running the following code:}{2}{section*.4}\protected@file@percent }
\newlabel{verify-that-your-function-works-correctly-by-running-the-following-code}{{}{2}{Verify that your function works correctly by running the following code:}{section*.4}{}}
\@writefile{toc}{\contentsline {subsubsection}{c.\nobreakspace  {}Install the R package microbenchmark. We will use this to discover the average duration your function takes.}{3}{section*.5}\protected@file@percent }
\newlabel{c.-install-the-r-package-microbenchmark.-we-will-use-this-to-discover-the-average-duration-your-function-takes.}{{}{3}{c.~Install the R package microbenchmark. We will use this to discover the average duration your function takes}{section*.5}{}}
\@writefile{toc}{\contentsline {subsubsection}{This will call the input R expression 100 times and report summary statistics on how long it took for the code to run. In particular, look at the median time for evaluation.}{3}{section*.6}\protected@file@percent }
\newlabel{this-will-call-the-input-r-expression-100-times-and-report-summary-statistics-on-how-long-it-took-for-the-code-to-run.-in-particular-look-at-the-median-time-for-evaluation.}{{}{3}{This will call the input R expression 100 times and report summary statistics on how long it took for the code to run. In particular, look at the median time for evaluation}{section*.6}{}}
\@writefile{toc}{\contentsline {subsubsection}{d.\nobreakspace  {}Instead of using a for loop, it might have been easier to use an ifelse() command. Rewrite your function to avoid the for loop and just use an ifelse() command. Verify that your function works correctly by producing a plot, and also run the microbenchmark(). Which version of your function was easier to write? Which ran faster?}{3}{section*.7}\protected@file@percent }
\newlabel{d.-instead-of-using-a-for-loop-it-might-have-been-easier-to-use-an-ifelse-command.-rewrite-your-function-to-avoid-the-for-loop-and-just-use-an-ifelse-command.-verify-that-your-function-works-correctly-by-producing-a-plot-and-also-run-the-microbenchmark.-which-version-of-your-function-was-easier-to-write-which-ran-faster}{{}{3}{d.~Instead of using a for loop, it might have been easier to use an ifelse() command. Rewrite your function to avoid the for loop and just use an ifelse() command. Verify that your function works correctly by producing a plot, and also run the microbenchmark(). Which version of your function was easier to write? Which ran faster?}{section*.7}{}}
\@writefile{toc}{\contentsline {subsubsection}{(2) 3 -- 2 pts. A common data processing step is to standardize numeric variables by subtracting the mean and dividing by the standard deviation. Mathematically, the standardized value is defined as \(x = \frac  {x - \bar  {x}}{s}\) where \(\bar  {x}\) is the mean and s is the standard deviation. Create a function that takes an input vector of numerical values and produces an output vector of the standardized values. We will then apply this function to each numeric column in a data frame using the dplyr::across() or the dplyr::mutate\_if() commands. This is often done in model algorithms that rely on numerical optimization methods to find a solution. By keeping the scales of different predictor covariates the same, the numerical optimization routines generally work better.}{5}{section*.8}\protected@file@percent }
\newlabel{pts.-a-common-data-processing-step-is-to-standardize-numeric-variables-by-subtracting-the-mean-and-dividing-by-the-standard-deviation.-mathematically-the-standardized-value-is-defined-as-x-fracx---barxs-where-barx-is-the-mean-and-s-is-the-standard-deviation.-create-a-function-that-takes-an-input-vector-of-numerical-values-and-produces-an-output-vector-of-the-standardized-values.-we-will-then-apply-this-function-to-each-numeric-column-in-a-data-frame-using-the-dplyracross-or-the-dplyrmutate_if-commands.-this-is-often-done-in-model-algorithms-that-rely-on-numerical-optimization-methods-to-find-a-solution.-by-keeping-the-scales-of-different-predictor-covariates-the-same-the-numerical-optimization-routines-generally-work-better.}{{}{5}{\texorpdfstring {(2) 3 -- 2 pts. A common data processing step is to standardize numeric variables by subtracting the mean and dividing by the standard deviation. Mathematically, the standardized value is defined as \(x = \frac {x - \bar {x}}{s}\) where \(\bar {x}\) is the mean and s is the standard deviation. Create a function that takes an input vector of numerical values and produces an output vector of the standardized values. We will then apply this function to each numeric column in a data frame using the dplyr::across() or the dplyr::mutate\_if() commands. This is often done in model algorithms that rely on numerical optimization methods to find a solution. By keeping the scales of different predictor covariates the same, the numerical optimization routines generally work better.}{(2) 3 -- 2 pts. A common data processing step is to standardize numeric variables by subtracting the mean and dividing by the standard deviation. Mathematically, the standardized value is defined as x = \textbackslash frac\{x - \textbackslash bar\{x\}\}\{s\} where \textbackslash bar\{x\} is the mean and s is the standard deviation. Create a function that takes an input vector of numerical values and produces an output vector of the standardized values. We will then apply this function to each numeric column in a data frame using the dplyr::across() or the dplyr::mutate\_if() commands. This is often done in model algorithms that rely on numerical optimization methods to find a solution. By keeping the scales of different predictor covariates the same, the numerical optimization routines generally work better.}}{section*.8}{}}
\@writefile{toc}{\contentsline {subsection}{(3) 4 -- 3 pts. In this example, we'll write a function that will output a vector of the first n terms in the child's game Fizz Buzz. The goal is to count as high as you can, but for any number evenly divisible by 3, substitute ``Fizz'' and any number evenly divisible by 5, substitute ``Buzz,'' and if it is divisible by both, substitute ``Fizz Buzz.'' So the sequence will look like 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, \ldots  {} Hint: The paste() function will squish strings together, the remainder operator is \%\% where it is used as 9 \%\% 3 = 0. This problem was inspired by a wonderful YouTube video that describes how to write an appropriate loop to do this in JavaScript, but it should be easy enough to interpret what to do in R. I encourage you to try to write your function first before watching the video.}{8}{section*.9}\protected@file@percent }
\newlabel{pts.-in-this-example-well-write-a-function-that-will-output-a-vector-of-the-first-n-terms-in-the-childs-game-fizz-buzz.-the-goal-is-to-count-as-high-as-you-can-but-for-any-number-evenly-divisible-by-3-substitute-fizz-and-any-number-evenly-divisible-by-5-substitute-buzz-and-if-it-is-divisible-by-both-substitute-fizz-buzz.-so-the-sequence-will-look-like-1-2-fizz-4-buzz-fizz-7-8-fizz-hint-the-paste-function-will-squish-strings-together-the-remainder-operator-is-where-it-is-used-as-9-3-0.-this-problem-was-inspired-by-a-wonderful-youtube-video-that-describes-how-to-write-an-appropriate-loop-to-do-this-in-javascript-but-it-should-be-easy-enough-to-interpret-what-to-do-in-r.-i-encourage-you-to-try-to-write-your-function-first-before-watching-the-video.}{{}{8}{(3) 4 -- 3 pts. In this example, we'll write a function that will output a vector of the first n terms in the child's game Fizz Buzz. The goal is to count as high as you can, but for any number evenly divisible by 3, substitute ``Fizz'' and any number evenly divisible by 5, substitute ``Buzz,'' and if it is divisible by both, substitute ``Fizz Buzz.'' So the sequence will look like 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, \ldots {} Hint: The paste() function will squish strings together, the remainder operator is \%\% where it is used as 9 \%\% 3 = 0. This problem was inspired by a wonderful YouTube video that describes how to write an appropriate loop to do this in JavaScript, but it should be easy enough to interpret what to do in R. I encourage you to try to write your function first before watching the video}{section*.9}{}}
\@writefile{toc}{\contentsline {subsection}{(4) 5 -- 3 pts The dplyr::fill() function takes a table column that has missing values and fills them with the most recent non-missing value. For this problem, we will create our own function to do the same.}{11}{section*.10}\protected@file@percent }
\newlabel{pts-the-dplyrfill-function-takes-a-table-column-that-has-missing-values-and-fills-them-with-the-most-recent-non-missing-value.-for-this-problem-we-will-create-our-own-function-to-do-the-same.}{{}{11}{(4) 5 -- 3 pts The dplyr::fill() function takes a table column that has missing values and fills them with the most recent non-missing value. For this problem, we will create our own function to do the same}{section*.10}{}}
\@writefile{toc}{\contentsline {subsubsection}{The following function call should produce the following ouput:}{11}{section*.11}\protected@file@percent }
\newlabel{the-following-function-call-should-produce-the-following-ouput}{{}{11}{The following function call should produce the following ouput:}{section*.11}{}}
\@writefile{toc}{\contentsline {subsection}{(5) 6 -- If you finish early on Friday of week 7 or before, please continue to exercise 6. +1 extra if problem 6 is submitted with Assignment 3 before the end of Friday's class.}{11}{section*.12}\protected@file@percent }
\newlabel{if-you-finish-early-on-friday-of-week-7-or-before-please-continue-to-exercise-6.-1-extra-if-problem-6-is-submitted-with-assignment-3-before-the-end-of-fridays-class.}{{}{11}{(5) 6 -- If you finish early on Friday of week 7 or before, please continue to exercise 6. +1 extra if problem 6 is submitted with Assignment 3 before the end of Friday's class}{section*.12}{}}
\@writefile{toc}{\contentsline {subsection}{A common statistical requirement is to create bootstrap confidence intervals for a model statistic. This is done by repeatedly re-sampling with replacement from our original sample data, running the analysis for each re-sample, and then saving the statistic of interest. Below is a function boot.lm that bootstraps the linear model using case re-sampling}{11}{section*.13}\protected@file@percent }
\newlabel{a-common-statistical-requirement-is-to-create-bootstrap-confidence-intervals-for-a-model-statistic.-this-is-done-by-repeatedly-re-sampling-with-replacement-from-our-original-sample-data-running-the-analysis-for-each-re-sample-and-then-saving-the-statistic-of-interest.-below-is-a-function-boot.lm-that-bootstraps-the-linear-model-using-case-re-sampling}{{}{11}{A common statistical requirement is to create bootstrap confidence intervals for a model statistic. This is done by repeatedly re-sampling with replacement from our original sample data, running the analysis for each re-sample, and then saving the statistic of interest. Below is a function boot.lm that bootstraps the linear model using case re-sampling}{section*.13}{}}
\@writefile{toc}{\contentsline {subsection}{(6) Turned in by the due date/time -- 1 point.}{13}{section*.14}\protected@file@percent }
\newlabel{turned-in-by-the-due-datetime-1-point.}{{}{13}{(6) Turned in by the due date/time -- 1 point}{section*.14}{}}
\@writefile{toc}{\contentsline {subsubsection}{Separate the results of each exercise with \#\# Exercise n, where n is the exercise number.}{13}{section*.15}\protected@file@percent }
\newlabel{separate-the-results-of-each-exercise-with-exercise-n-where-n-is-the-exercise-number.}{{}{13}{Separate the results of each exercise with \#\# Exercise n, where n is the exercise number}{section*.15}{}}
\gdef \@abspage@last{13}
